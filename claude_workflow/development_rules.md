# Development Rules & Patterns

**Last Updated**: July 1, 2025 - Added API-First Patterns and Modular Architecture

## TDD (Test-Driven Development) Methodology

### TDD Workflow (MANDATORY)
All new features and bug fixes MUST follow Red-Green-Refactor cycle:

1. **RED**: Write failing test first
   - Write test that describes the desired behavior
   - Run test to confirm it fails (especially for race conditions)
   - Test should fail for the right reason
   - Use Selenium for UI race condition testing

2. **GREEN**: Write minimal code to pass
   - Implement simplest solution that makes test pass
   - Don't optimize yet - just make it work
   - Run test to confirm it passes
   - Validate with millisecond-precision Selenium tests

3. **REFACTOR**: Improve code quality
   - Clean up code while keeping tests green
   - Remove duplication, improve readability
   - Ensure all tests still pass
   - Add comprehensive console logging for debugging

### TDD Rules for This Project
- **No production code** without a failing test first
- **Tests must be isolated** - no dependencies between tests
- **Use descriptive test names** that explain behavior
- **Test one behavior per test** - keep tests focused
- **Mock external dependencies** (WebDAV, file system)

### Testing Framework Structure
```python
# Test file naming: test_<module>_<feature>.py
# Test class naming: Test<Feature><Behavior>
# Test method naming: test_<action>_<expected_result>

class TestComponentPictureVisibility:
    def test_create_variant_with_picture_shows_immediately(self):
        # Given: component exists
        # When: variant with picture is created
        # Then: picture is visible in component detail
```

### Testing Patterns for Flask Components

#### Unit Tests (Fast)
```python
# Test business logic in isolation
def test_generate_variant_sku_with_supplier():
    # Test SKU generation logic
    pass

def test_picture_name_generation():
    # Test picture naming logic
    pass
```

#### Integration Tests (Medium)
```python
# Test database operations
def test_component_variant_creation_updates_sku():
    # Test database triggers work correctly
    pass

def test_picture_save_with_rollback():
    # Test transaction rollback on file save failure
    pass
```

#### End-to-End Tests (Slow)
```python
# Test complete user workflows
def test_component_edit_picture_visibility_workflow():
    # Test complete picture upload and visibility
    pass
```

### Test Data Management
- Use **fixtures** for consistent test data
- **Clean up after tests** - restore database state
- **Use test-specific data** - avoid shared state
- **Mock WebDAV operations** for unit tests

### TDD for UI Race Conditions (PROVEN PATTERN)
1. **Write Selenium test** that detects timing issues with millisecond precision
2. **Implement multi-layer solutions** to pass all timing scenarios
3. **Refactor** with console logging and comprehensive fallbacks

Example Pattern for Loading Indicators:
- Layer 1: Immediate CSS (`body[data-attribute]`)
- Layer 2: JavaScript URL parameter detection
- Layer 3: Alpine.js component factory initialization
- Layer 4: API auto-refresh with exponential backoff

### Testing Commands
```bash
# Run all tests
pytest

# Run specific test file
pytest tests/test_component_pictures.py

# Run with coverage
pytest --cov=app

# Run only fast tests
pytest -m "not slow"
```

## Core Development Constraints

### 1. Database Operations
- **ALWAYS** use database triggers for SKU and picture name generation
- **NEVER** manually set `variant_sku` or `picture_name` fields
- Use `selectinload` for better performance with collections
- All models inherit from `Base` class with `component_app` schema
- Clear session cache with `db.session.expunge_all()` after picture operations

### 2. Picture Management Rules
- Pictures stored in `/components/` directory (no subfolders)
- Automatic naming: `{supplier_code}_{product_number}_{color}_{order}` or `{product_number}_{color}_{order}`
- WebDAV URL prefix: `http://31.182.67.115/webdav/components`
- Image optimization: max 1920x1920, JPEG quality 85
- Always implement transaction rollback for failed saves

### 3. File Upload Workflow (MANDATORY)
1. Files read into memory during form processing
2. Database records created first (triggers generate names)
3. Files saved to disk with generated names
4. URLs updated in database
5. Session cache cleared with `db.session.expunge_all()`

### 4. Component Variant Rules
- Each component must have at least one variant
- Each variant must have at least one picture
- Colors are unique per component
- SKUs auto-generated by database triggers

## Required Code Patterns

### Database Query Pattern
```python
# ALWAYS use selectinload for collections
component = Component.query.options(
    joinedload(Component.component_type),
    selectinload(Component.variants).joinedload(ComponentVariant.color),
    selectinload(Component.pictures)
).get_or_404(id)
```

### Picture Saving Pattern (REQUIRED)
```python
# Always track saved files for rollback
saved_files = []
try:
    # Save files and track paths
    saved_files.append(file_path)
    db.session.commit()
except Exception:
    # Clean up saved files on failure
    for file_path in saved_files:
        if os.path.exists(file_path):
            os.remove(file_path)
    raise
```

### CSRF Protection (MANDATORY)
- All forms must include `{{ csrf_token() }}`
- AJAX requests must include `X-CSRFToken` header

## Areas of Caution

### 1. Session Caching Issues
- Use `db.session.expunge_all()` after picture operations
- Implement AJAX refresh for data consistency
- Multiple retry attempts with exponential backoff

### 2. File Operations
- Always use atomic operations for file saving
- Implement proper cleanup on failures
- Validate file types server-side

### 3. Database Triggers
- Never bypass database-generated fields
- Understand trigger cascade effects
- Test SKU/name generation after changes

## Code Quality Standards

### Error Handling
- Implement comprehensive try/catch blocks
- Log all file operations and errors
- Provide user-friendly error messages
- Always clean up resources on failure

### Performance Requirements
- Use selectinload for collections
- Implement query optimization
- Cache expensive operations
- Monitor database query performance

### Security Requirements
- CSRF protection on all forms
- File upload validation
- SQL injection prevention via SQLAlchemy
- Secure file handling practices

## Testing Requirements (Updated for TDD)

### TDD Testing Hierarchy
1. **Unit Tests** (milliseconds) - Business logic, utilities, model methods
2. **Integration Tests** (seconds) - Database operations, API endpoints
3. **End-to-End Tests** (minutes) - Complete user workflows via Selenium

### Test Coverage Requirements
- **Minimum 80% code coverage** for new features
- **100% coverage** for critical paths (picture operations, SKU generation)
- **All database triggers** must have corresponding tests
- **All AJAX endpoints** must have integration tests

### TDD-Specific Testing Patterns
```python
# Example: Testing picture visibility with TDD approach
class TestComponentPictureVisibility:
    
    def test_variant_picture_visible_immediately_after_creation(self):
        # RED: This test should fail initially
        component = create_test_component()
        variant_data = {'color_id': 1, 'pictures': [test_image]}
        
        response = client.post(f'/components/{component.id}/variants', data=variant_data)
        
        # Should be visible without page refresh
        response = client.get(f'/components/{component.id}')
        assert 'test_image' in response.data
    
    def test_ajax_refresh_loads_new_pictures(self):
        # Test the AJAX solution specifically
        pass
```

### Manual Testing Checklist (Post-TDD)
- Run automated test suite first
- Component creation with variants and pictures
- Component editing with picture changes  
- Picture visibility in component detail view
- AJAX refresh mechanism working
- No JavaScript console errors
- Cross-browser compatibility (Chrome, Firefox)

### Automated Testing (Enhanced)
- **pytest** for unit/integration tests
- **Selenium** for end-to-end workflows
- **Coverage.py** for code coverage tracking
- **Factory Boy** for test data generation
- **Mock/patch** for external dependencies (WebDAV)

## API-First Architecture Patterns (NEW - JULY 2025)

### Separation of Concerns (MANDATORY)
**CRITICAL RULE**: Clear separation between web routes and API endpoints established during variant management migration:

#### Web Routes (`/app/web/`)
- **Purpose**: Page rendering and navigation only
- **Responsibilities**: Template rendering, form display, redirect logic
- **NO DATA OPERATIONS**: Forms should not process variants, pictures, or complex operations
- **Pattern**: Return rendered templates or simple redirects

```python
# Good: Web route for page rendering
@component_web.route('/components/<int:id>/edit')
def edit_component(id):
    component = get_component_with_relationships(id)
    return render_template('component_edit_form.html', component=component)

# Bad: Web route doing complex data operations (OLD PATTERN)
@component_web.route('/components', methods=['POST'])
def create_component():
    # Complex variant/picture processing - SHOULD BE IN API
    pass
```

#### API Endpoints (`/app/api/`)
- **Purpose**: Data operations and business logic
- **Responsibilities**: CRUD operations, file handling, validation, database operations
- **Return JSON**: Always return structured JSON responses
- **Proper Error Handling**: HTTP status codes and error messages

```python
# Good: API endpoint for data operations
@variant_api.route('/<int:variant_id>/pictures', methods=['POST'])
def add_variant_pictures(variant_id):
    try:
        # Business logic here
        return jsonify({'success': True, 'pictures': pictures_data})
    except Exception as e:
        return jsonify({'error': str(e)}), 500
```

### JavaScript API Integration Pattern
**MANDATORY**: Frontend must use API endpoints for real-time operations:

```javascript
// Good: API-first frontend pattern
class VariantManager {
    async createVariantViaAPI(variantId) {
        const response = await fetch('/api/variant/create', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': this.csrfToken
            },
            body: JSON.stringify(variantData)
        });
        
        if (response.ok) {
            const result = await response.json();
            this.updateUI(result);
        } else {
            this.handleError(response);
        }
    }
}

// Bad: Form-based approach (OLD PATTERN)
function submitVariantForm() {
    // Submitting forms for real-time operations
}
```

### Smart Creation Workflow Pattern
**NEW PATTERN**: Component creation with API-based variant management:

1. **Component Creation**: Submit form to create component (web route)
2. **Extract Component ID**: From redirect URL or response
3. **Variant Creation**: Use API endpoints to create variants with pictures
4. **Real-time Updates**: No page reload needed for variant operations

```javascript
// Implementation pattern
async function handleNewComponentSubmission() {
    // 1. Create component via form submission
    const formData = new FormData(form);
    // Remove variant fields - they'll be handled via API
    removeVariantFields(formData);
    
    const response = await fetch(form.action, {
        method: 'POST',
        body: formData
    });
    
    // 2. Extract component ID from redirect
    const componentId = extractComponentId(response);
    
    // 3. Create variants via API
    await this.createVariantsViaAPI(componentId);
    
    // 4. Redirect to component detail
    window.location.href = response.url;
}
```

### File Handling with Database Integration
**CRITICAL PATTERN**: Proper WebDAV and database trigger integration:

```python
# Good: Let database generate names, then save files
@variant_api.route('/<int:variant_id>/pictures', methods=['POST'])
def add_variant_pictures(variant_id):
    try:
        # 1. Create picture records (triggers generate names)
        pictures = []
        for file in files:
            picture = Picture(
                component_id=variant.component_id,
                variant_id=variant_id,
                picture_order=order,
                # DO NOT set picture_name - database trigger handles this
            )
            db.session.add(picture)
        
        db.session.commit()  # Triggers generate picture names
        
        # 2. Save files with generated names
        for picture, file in zip(pictures, files):
            file_path = f"/components/{picture.picture_name}"
            save_uploaded_file(file, file_path)
            picture.url = f"http://31.182.67.115/webdav{file_path}"
        
        db.session.commit()
        return jsonify({'success': True, 'pictures': pictures_data})
        
    except Exception as e:
        db.session.rollback()
        # Clean up any saved files
        cleanup_saved_files(saved_files)
        return jsonify({'error': str(e)}), 500
```

### Error Handling and User Feedback
**ENHANCED PATTERN**: Professional loading states and error handling:

```javascript
// Loading states for API operations
async function performOperation() {
    try {
        this.showLoadingIndicator('Processing...');
        
        const response = await this.apiCall();
        
        if (response.ok) {
            this.showSuccessMessage('Operation completed');
            this.updateUI(response.data);
        } else {
            throw new Error(`Server error: ${response.status}`);
        }
    } catch (error) {
        this.showErrorMessage(`Operation failed: ${error.message}`);
    } finally {
        this.hideLoadingIndicator();
    }
}
```

## Modular Architecture Patterns (ESTABLISHED)

### Frontend Organization Rules
**MANDATORY**: All new features must follow modular architecture pattern established for component-detail and component-edit:

#### CSS Module Structure
```
app/static/css/<feature-name>/
├── main.css           # Entry point with @import statements
├── variables.css      # Design system variables
├── base.css           # Reset and typography
├── layout.css         # Grid and page structure
├── <feature>.css      # Feature-specific styles (variants, forms, etc.)
└── responsive.css     # Mobile and accessibility
```

#### JavaScript Module Structure  
```
app/static/js/<feature-name>/
├── <main-handler>.js  # Primary functionality (e.g., form-handler.js)
├── <feature1>.js      # Specific feature modules (e.g., variant-manager.js)
├── <feature2>.js      # Additional features (e.g., keyword-autocomplete.js)
└── utils.js           # Shared utilities (if needed)
```

### Modular Architecture Benefits
- **Maintainability**: Each file focuses on single responsibility
- **Debugging**: Issues can be traced to specific modules
- **Performance**: Better browser caching of modular files
- **Consistency**: Same patterns across all forms/pages
- **Scalability**: New features added as separate modules

### Refactoring Guidelines
When encountering large monolithic CSS/JS files:
1. **Analyze sections**: Look for natural boundaries (comments, functionality)
2. **Create module structure**: Follow established patterns
3. **Extract incrementally**: One module at a time with testing
4. **Update references**: Template files to point to new modules
5. **Delete original**: Only after verification all modules work

### Template Integration
```html
<!-- Template data initialization -->
<script>
    window.featureData = {{ template_data|tojson }};
    window.isEditMode = {{ is_edit|tojson }};
</script>

<!-- Modular CSS -->
<link rel="stylesheet" href="{{ url_for('static', filename='css/feature-name/main.css') }}">

<!-- Modular JavaScript -->
<script src="{{ url_for('static', filename='js/feature-name/main-handler.js') }}"></script>
<script src="{{ url_for('static', filename='js/feature-name/feature-manager.js') }}"></script>
```

## Deployment Patterns

### Common Commands
- Start: `./start.sh`
- Restart: `./restart.sh`
- Status: `./start.sh status`
- Logs: `docker-compose logs`

### Database Migrations
- Always use Flask-Migrate
- Test migrations in development first
- Backup before production migrations
- Schema: `component_app`