# Development Rules & Patterns

**Last Updated**: June 30, 2025 - Added Loading System Patterns

## TDD (Test-Driven Development) Methodology

### TDD Workflow (MANDATORY)
All new features and bug fixes MUST follow Red-Green-Refactor cycle:

1. **RED**: Write failing test first
   - Write test that describes the desired behavior
   - Run test to confirm it fails (especially for race conditions)
   - Test should fail for the right reason
   - Use Selenium for UI race condition testing

2. **GREEN**: Write minimal code to pass
   - Implement simplest solution that makes test pass
   - Don't optimize yet - just make it work
   - Run test to confirm it passes
   - Validate with millisecond-precision Selenium tests

3. **REFACTOR**: Improve code quality
   - Clean up code while keeping tests green
   - Remove duplication, improve readability
   - Ensure all tests still pass
   - Add comprehensive console logging for debugging

### TDD Rules for This Project
- **No production code** without a failing test first
- **Tests must be isolated** - no dependencies between tests
- **Use descriptive test names** that explain behavior
- **Test one behavior per test** - keep tests focused
- **Mock external dependencies** (WebDAV, file system)

### Testing Framework Structure
```python
# Test file naming: test_<module>_<feature>.py
# Test class naming: Test<Feature><Behavior>
# Test method naming: test_<action>_<expected_result>

class TestComponentPictureVisibility:
    def test_create_variant_with_picture_shows_immediately(self):
        # Given: component exists
        # When: variant with picture is created
        # Then: picture is visible in component detail
```

### Testing Patterns for Flask Components

#### Unit Tests (Fast)
```python
# Test business logic in isolation
def test_generate_variant_sku_with_supplier():
    # Test SKU generation logic
    pass

def test_picture_name_generation():
    # Test picture naming logic
    pass
```

#### Integration Tests (Medium)
```python
# Test database operations
def test_component_variant_creation_updates_sku():
    # Test database triggers work correctly
    pass

def test_picture_save_with_rollback():
    # Test transaction rollback on file save failure
    pass
```

#### End-to-End Tests (Slow)
```python
# Test complete user workflows
def test_component_edit_picture_visibility_workflow():
    # Test complete picture upload and visibility
    pass
```

### Test Data Management
- Use **fixtures** for consistent test data
- **Clean up after tests** - restore database state
- **Use test-specific data** - avoid shared state
- **Mock WebDAV operations** for unit tests

### TDD for UI Race Conditions (PROVEN PATTERN)
1. **Write Selenium test** that detects timing issues with millisecond precision
2. **Implement multi-layer solutions** to pass all timing scenarios
3. **Refactor** with console logging and comprehensive fallbacks

Example Pattern for Loading Indicators:
- Layer 1: Immediate CSS (`body[data-attribute]`)
- Layer 2: JavaScript URL parameter detection
- Layer 3: Alpine.js component factory initialization
- Layer 4: API auto-refresh with exponential backoff

### Testing Commands
```bash
# Run all tests
pytest

# Run specific test file
pytest tests/test_component_pictures.py

# Run with coverage
pytest --cov=app

# Run only fast tests
pytest -m "not slow"
```

## Core Development Constraints

### 1. Database Operations
- **ALWAYS** use database triggers for SKU and picture name generation
- **NEVER** manually set `variant_sku` or `picture_name` fields
- Use `selectinload` for better performance with collections
- All models inherit from `Base` class with `component_app` schema
- Clear session cache with `db.session.expunge_all()` after picture operations

### 2. Picture Management Rules
- Pictures stored in `/components/` directory (no subfolders)
- Automatic naming: `{supplier_code}_{product_number}_{color}_{order}` or `{product_number}_{color}_{order}`
- WebDAV URL prefix: `http://31.182.67.115/webdav/components`
- Image optimization: max 1920x1920, JPEG quality 85
- Always implement transaction rollback for failed saves

### 3. File Upload Workflow (MANDATORY)
1. Files read into memory during form processing
2. Database records created first (triggers generate names)
3. Files saved to disk with generated names
4. URLs updated in database
5. Session cache cleared with `db.session.expunge_all()`

### 4. Component Variant Rules
- Each component must have at least one variant
- Each variant must have at least one picture
- Colors are unique per component
- SKUs auto-generated by database triggers

## Required Code Patterns

### Database Query Pattern
```python
# ALWAYS use selectinload for collections
component = Component.query.options(
    joinedload(Component.component_type),
    selectinload(Component.variants).joinedload(ComponentVariant.color),
    selectinload(Component.pictures)
).get_or_404(id)
```

### Picture Saving Pattern (REQUIRED)
```python
# Always track saved files for rollback
saved_files = []
try:
    # Save files and track paths
    saved_files.append(file_path)
    db.session.commit()
except Exception:
    # Clean up saved files on failure
    for file_path in saved_files:
        if os.path.exists(file_path):
            os.remove(file_path)
    raise
```

### CSRF Protection (MANDATORY)
- All forms must include `{{ csrf_token() }}`
- AJAX requests must include `X-CSRFToken` header

## Areas of Caution

### 1. Session Caching Issues
- Use `db.session.expunge_all()` after picture operations
- Implement AJAX refresh for data consistency
- Multiple retry attempts with exponential backoff

### 2. File Operations
- Always use atomic operations for file saving
- Implement proper cleanup on failures
- Validate file types server-side

### 3. Database Triggers
- Never bypass database-generated fields
- Understand trigger cascade effects
- Test SKU/name generation after changes

## Code Quality Standards

### Error Handling
- Implement comprehensive try/catch blocks
- Log all file operations and errors
- Provide user-friendly error messages
- Always clean up resources on failure

### Performance Requirements
- Use selectinload for collections
- Implement query optimization
- Cache expensive operations
- Monitor database query performance

### Security Requirements
- CSRF protection on all forms
- File upload validation
- SQL injection prevention via SQLAlchemy
- Secure file handling practices

## Testing Requirements (Updated for TDD)

### TDD Testing Hierarchy
1. **Unit Tests** (milliseconds) - Business logic, utilities, model methods
2. **Integration Tests** (seconds) - Database operations, API endpoints
3. **End-to-End Tests** (minutes) - Complete user workflows via Selenium

### Test Coverage Requirements
- **Minimum 80% code coverage** for new features
- **100% coverage** for critical paths (picture operations, SKU generation)
- **All database triggers** must have corresponding tests
- **All AJAX endpoints** must have integration tests

### TDD-Specific Testing Patterns
```python
# Example: Testing picture visibility with TDD approach
class TestComponentPictureVisibility:
    
    def test_variant_picture_visible_immediately_after_creation(self):
        # RED: This test should fail initially
        component = create_test_component()
        variant_data = {'color_id': 1, 'pictures': [test_image]}
        
        response = client.post(f'/components/{component.id}/variants', data=variant_data)
        
        # Should be visible without page refresh
        response = client.get(f'/components/{component.id}')
        assert 'test_image' in response.data
    
    def test_ajax_refresh_loads_new_pictures(self):
        # Test the AJAX solution specifically
        pass
```

### Manual Testing Checklist (Post-TDD)
- Run automated test suite first
- Component creation with variants and pictures
- Component editing with picture changes  
- Picture visibility in component detail view
- AJAX refresh mechanism working
- No JavaScript console errors
- Cross-browser compatibility (Chrome, Firefox)

### Automated Testing (Enhanced)
- **pytest** for unit/integration tests
- **Selenium** for end-to-end workflows
- **Coverage.py** for code coverage tracking
- **Factory Boy** for test data generation
- **Mock/patch** for external dependencies (WebDAV)

## Deployment Patterns

### Common Commands
- Start: `./start.sh`
- Restart: `./restart.sh`
- Status: `./start.sh status`
- Logs: `docker-compose logs`

### Database Migrations
- Always use Flask-Migrate
- Test migrations in development first
- Backup before production migrations
- Schema: `component_app`