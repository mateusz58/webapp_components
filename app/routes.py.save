import os
import json
from flask import Blueprint, render_template, request, flash, redirect, url_for, current_app, jsonify, send_file
from werkzeug.utils import secure_filename
from app import db
from app.models import Supplier, Category, Color, Material, Component, Picture, ComponentType, Keyword, ComponentVariant
from app.utils import process_csv_file
from sqlalchemy import or_, text, func
from datetime import datetime, timedelta
import uuid
import io
import csv

main = Blueprint('main', __name__)

def allowed_file(filename):
    """Check if the uploaded file has an allowed extension."""
    ALLOWED_EXTENSIONS = {'csv'}
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

@main.route('/')
def index():
    """Modern dashboard with enhanced filtering and search."""
    try:
        # Get filter parameters
        search = request.args.get('search', '').strip()
        component_type_id = request.args.get('component_type_id', type=int)
        category_id = request.args.get('category_id', type=int)
        supplier_id = request.args.get('supplier_id', type=int)
        status = request.args.get('status', '')
        recent = request.args.get('recent', type=int)
        
        # Base query with eager loading for performance
        query = Component.query.options(
            db.joinedload(Component.component_type),
            db.joinedload(Component.supplier),
            db.joinedload(Component.category),
            db.joinedload(Component.keywords),
            db.subqueryload(Component.pictures)
        )
        
        # Apply search filter
        if search:
            search_filter = or_(
                Component.product_number.ilike(f'%{search}%'),
                Component.description.ilike(f'%{search}%'),
                Component.keywords.any(Keyword.name.ilike(f'%{search}%'))
            )
            query = query.filter(search_filter)
        
        # Apply component type filter
        if component_type_id:
            query = query.filter(Component.component_type_id == component_type_id)
        
        # Apply category filter
        if category_id:
            query = query.filter(Component.category_id == category_id)
        
        # Apply supplier filter
        if supplier_id:
            query = query.filter(Component.supplier_id == supplier_id)
        
        # Apply status filter
        if status:
            if status == 'approved':
                query = query.filter(Component.pps_status == 'ok')
            elif status == 'pending':
                query = query.filter(or_(
                    Component.proto_status == 'pending',
                    Component.sms_status == 'pending',
                    Component.pps_status == 'pending'
                ))
            elif status == 'rejected':
                query = query.filter(or_(
                    Component.proto_status == 'not_ok',
                    Component.sms_status == 'not_ok',
                    Component.pps_status == 'not_ok'
                ))
        
        # Apply recent filter
        if recent:
            since_date = datetime.utcnow() - timedelta(days=recent)
            query = query.filter(Component.created_at >= since_date)
        
        # Get paginated results
        page = request.args.get('page', 1, type=int)
        per_page = request.args.get('per_page', 12, type=int)
        components = query.order_by(Component.created_at.desc()).paginate(
            page=page, 
            per_page=min(per_page, 50), 
            error_out=False
        )
        
        # Get filter options for dropdowns
        component_types = ComponentType.query.order_by(ComponentType.name).all()
        categories = Category.query.order_by(Category.name).all()
        suppliers = Supplier.query.order_by(Supplier.supplier_code).all()
        
        return render_template('index.html', 
                              components=components,
                              component_types=component_types,
                              categories=categories,
                              suppliers=suppliers,
                              search=search)
                              
    except Exception as e:
        current_app.logger.error(f"Error in index route: {str(e)}")
        return render_template('connection_error.html', error=str(e))

@main.route('/component/<int:id>')
def component_detail(id):
    """Enhanced component detail view."""
    try:
        component = Component.query.options(
            db.joinedload(Component.component_type),
            db.joinedload(Component.supplier),
            db.joinedload(Component.category),
            db.joinedload(Component.keywords),
            db.joinedload(Component.pictures),
            db.joinedload(Component.variants).joinedload(ComponentVariant.color)
        ).get_or_404(id)
        
        return render_template('component_detail.html', component=component)
        
    except Exception as e:
        current_app.logger.error(f"Error loading component {id}: {str(e)}")
        flash(f'Error loading component: {str(e)}', 'danger')
        return redirect(url_for('main.index'))

@main.route('/component/new', methods=['GET', 'POST'])
def new_component():
    """Enhanced component creation with wizard interface."""
    if request.method == 'POST':
        try:
            # Get form data
            product_number = request.form.get('product_number', '').strip()
            description = request.form.get('description', '').strip()
            component_type_id = request.form.get('component_type_id')
            supplier_id = request.form.get('supplier_id')
            category_id = request.form.get('category_id')
            
            # Validate required fields
            if not all([product_number, component_type_id, supplier_id, category_id]):
                flash('Please fill in all required fields.', 'danger')
                return redirect(request.url)
            
            # Check if product_number already exists for this supplier
            existing = Component.query.filter_by(
                product_number=product_number, 
                supplier_id=supplier_id
            ).first()
            if existing:
                flash('Product number already exists for this supplier.', 'danger')
                return redirect(request.url)
            
            # Create new component
            component = Component(
                product_number=product_number,
                description=description,
                component_type_id=int(component_type_id),
                supplier_id=int(supplier_id),
                category_id=int(category_id)
            )
            
            db.session.add(component)
            db.session.flush()  # Get the ID
            
            # Process keywords
            keywords = request.form.get('keywords', '').strip()
            if keywords:
                keyword_list = [k.strip().lower() for k in keywords.split(',') if k.strip()]
                for keyword_name in keyword_list:
                    keyword = Keyword.query.filter_by(name=keyword_name).first()
                    if not keyword:
                        keyword = Keyword(name=keyword_name)
                        db.session.add(keyword)
                    
                    if keyword not in component.keywords:
                        component.keywords.append(keyword)
            
            # Process flexible properties based on component type
            component_type = ComponentType.query.get(component_type_id)
            if component_type:
                _process_component_properties(component, component_type.name, request.form)
            
            # Process image uploads
            _process_image_uploads(component, request)
            
            db.session.commit()
            flash('Component created successfully!', 'success')
            return redirect(url_for('main.component_detail', id=component.id))
            
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Error creating component: {str(e)}")
            flash(f'Error creating component: {str(e)}', 'danger')
            return redirect(request.url)
    
    # GET request - show form
    component_types = ComponentType.query.order_by(ComponentType.name).all()
    categories = Category.query.order_by(Category.name).all()
    suppliers = Supplier.query.order_by(Supplier.supplier_code).all()
    colors = Color.query.order_by(Color.name).all()
    materials = Material.query.order_by(Material.name).all()
    
    return render_template('component_form.html', 
                          component_types=component_types,
                          categories=categories,
                          suppliers=suppliers,
                          colors=colors,
                          materials=materials)

@main.route('/component/edit/<int:id>', methods=['GET', 'POST'])
def edit_component(id):
    """Enhanced component editing."""
    component = Component.query.options(
        db.joinedload(Component.keywords),
        db.joinedload(Component.pictures)
    ).get_or_404(id)
    
    if request.method == 'POST':
        try:
            # Update basic information
            component.product_number = request.form.get('product_number', '').strip()
            component.description = request.form.get('description', '').strip()
            component.component_type_id = int(request.form.get('component_type_id'))
            component.supplier_id = int(request.form.get('supplier_id'))
            component.category_id = int(request.form.get('category_id'))
            
            # Update keywords
            component.keywords.clear()
            keywords = request.form.get('keywords', '').strip()
            if keywords:
                keyword_list = [k.strip().lower() for k in keywords.split(',') if k.strip()]
                for keyword_name in keyword_list:
                    keyword = Keyword.query.filter_by(name=keyword_name).first()
                    if not keyword:
                        keyword = Keyword(name=keyword_name)
                        db.session.add(keyword)
                    component.keywords.append(keyword)
            
            # Update properties
            component_type = ComponentType.query.get(component.component_type_id)
            if component_type:
                component.properties = {}  # Clear existing properties
                _process_component_properties(component, component_type.name, request.form)
            
            # Update images
            _update_component_images(component, request)
            
            db.session.commit()
            flash('Component updated successfully!', 'success')
            return redirect(url_for('main.component_detail', id=component.id))
            
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Error updating component {id}: {str(e)}")
            flash(f'Error updating component: {str(e)}', 'danger')
            return redirect(request.url)
    
    # GET request - show form with existing data
    component_types = ComponentType.query.order_by(ComponentType.name).all()
    categories = Category.query.order_by(Category.name).all()
    suppliers = Supplier.query.order_by(Supplier.supplier_code).all()
    colors = Color.query.order_by(Color.name).all()
    materials = Material.query.order_by(Material.name).all()
    
    return render_template('component_form.html', 
                          component=component,
                          component_types=component_types,
                          categories=categories,
                          suppliers=suppliers,
                          colors=colors,
                          materials=materials)

@main.route('/component/delete/<int:id>', methods=['POST'])
def delete_component(id):
    """Delete a component with cascade."""
    try:
        component = Component.query.get_or_404(id)
        
        # Delete associated pictures and variants (handled by cascade)
        db.session.delete(component)
        db.session.commit()
        
        flash('Component deleted successfully!', 'success')
        return redirect(url_for('main.index'))
        
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f"Error deleting component {id}: {str(e)}")
        flash(f'Error deleting component: {str(e)}', 'danger')
        return redirect(url_for('main.component_detail', id=id))

# Status Management Routes
@main.route('/component/<int:id>/status/proto', methods=['POST'])
def update_proto_status(id):
    """Update proto status for a component."""
    try:
        component = Component.query.get_or_404(id)
        status = request.form.get('status')
        comment = request.form.get('comment', '').strip()
        
        component.update_proto_status(status, comment if comment else None)
        db.session.commit()
        
        flash(f'Proto status updated to {status}', 'success')
        return redirect(url_for('main.component_detail', id=id))
        
    except ValueError as e:
        flash(str(e), 'danger')
        return redirect(url_for('main.component_detail', id=id))
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f"Error updating proto status: {str(e)}")
        flash(f'Error updating status: {str(e)}', 'danger')
        return redirect(url_for('main.component_detail', id=id))

@main.route('/component/<int:id>/status/sms', methods=['POST'])
def update_sms_status(id):
    """Update SMS status for a component."""
    try:
        component = Component.query.get_or_404(id)
        status = request.form.get('status')
        comment = request.form.get('comment', '').strip()
        
        component.update_sms_status(status, comment if comment else None)
        db.session.commit()
        
        flash(f'SMS status updated to {status}', 'success')
        return redirect(url_for('main.component_detail', id=id))
        
    except ValueError as e:
        flash(str(e), 'danger')
        return redirect(url_for('main.component_detail', id=id))
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f"Error updating SMS status: {str(e)}")
        flash(f'Error updating status: {str(e)}', 'danger')
        return redirect(url_for('main.component_detail', id=id))

@main.route('/component/<int:id>/status/pps', methods=['POST'])
def update_pps_status(id):
    """Update PPS status for a component."""
    try:
        component = Component.query.get_or_404(id)
        status = request.form.get('status')
        comment = request.form.get('comment', '').strip()
        
        component.update_pps_status(status, comment if comment else None)
        db.session.commit()
        
        flash(f'PPS status updated to {status}', 'success')
        return redirect(url_for('main.component_detail', id=id))
        
    except ValueError as e:
        flash(str(e), 'danger')
        return redirect(url_for('main.component_detail', id=id))
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f"Error updating PPS status: {str(e)}")
        flash(f'Error updating status: {str(e)}', 'danger')
        return redirect(url_for('main.component_detail', id=id))

# Variant Management Routes
@main.route('/component/<int:id>/variant/new', methods=['GET', 'POST'])
def new_variant(id):
    """Create a new variant for a component."""
    component = Component.query.get_or_404(id)
    
    if request.method == 'POST':
        try:
            color_id = request.form.get('color_id')
            variant_name = request.form.get('variant_name', '').strip()
            description = request.form.get('description', '').strip()
            
            if not color_id:
                flash('Please select a color for the variant.', 'danger')
                return redirect(request.url)
            
            variant = component.create_variant(
                color_id=int(color_id),
                variant_name=variant_name if variant_name else None,
                description=description if description else None
            )
            
            db.session.add(variant)
            db.session.commit()
            
            flash('Variant created successfully!', 'success')
            return redirect(url_for('main.component_detail', id=id))
            
        except ValueError as e:
            flash(str(e), 'danger')
            return redirect(request.url)
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Error creating variant: {str(e)}")
            flash(f'Error creating variant: {str(e)}', 'danger')
            return redirect(request.url)
    
    # GET request
    colors = Color.query.order_by(Color.name).all()
    return render_template('variant_form.html', component=component, colors=colors)

@main.route('/upload', methods=['GET', 'POST'])
def upload_csv():
    """Enhanced CSV upload with progress tracking."""
    if request.method == 'POST':
        try:
            # Check if a file was uploaded
            if 'file' not in request.files:
                return jsonify({'success': False, 'error': 'No file uploaded'}), 400
            
            file = request.files['file']
            
            # Check if a file was selected
            if file.filename == '':
                return jsonify({'success': False, 'error': 'No file selected'}), 400
            
            # Check if the file has an allowed extension
            if file and allowed_file(file.filename):
                filename = secure_filename(file.filename)
                temp_path = os.path.join(current_app.config['UPLOAD_FOLDER'], f"temp_{uuid.uuid4().hex}_{filename}")
                file.save(temp_path)
                
                # Process the CSV file
                results = process_csv_file(temp_path)
                
                # Delete the temporary file
                os.remove(temp_path)
                
                # Return results as JSON for AJAX requests
                if request.headers.get('Content-Type') == 'application/json':
                    return jsonify({
                        'success': True,
                        'results': results
                    })
                
                # Handle traditional form submission
                if results['errors']:
                    for error in results['errors']:
                        flash(error, 'danger')
                else:
                    flash(f"CSV processed successfully! Created: {results['created']}, Updated: {results['updated']}", 'success')
                
                return redirect(url_for('main.index'))
            else:
                error_msg = 'File type not allowed. Please upload a CSV file.'
                if request.headers.get('Content-Type') == 'application/json':
                    return jsonify({'success': False, 'error': error_msg}), 400
                flash(error_msg, 'danger')
                return redirect(request.url)
                
        except Exception as e:
            current_app.logger.error(f"Error processing CSV: {str(e)}")
            error_msg = f'Error processing file: {str(e)}'
            if request.headers.get('Content-Type') == 'application/json':
                return jsonify({'success': False, 'error': error_msg}), 500
            flash(error_msg, 'danger')
            return redirect(request.url)
    
    # GET request - show upload form
    return render_template('upload.html')

@main.route('/download/csv-template')
def download_csv_template():
    """Generate and download CSV template."""
    try:
        # Create CSV template
        template_data = [
            [
                'product_number', 'description', 'component_type', 'supplier_code', 
                'category_name', 'keywords', 'material', 'color', 'gender', 'style', 
                'brand', 'subbrand', 'size', 'picture_1_name', 'picture_1_url', 'picture_1_order',
                'picture_2_name', 'picture_2_url', 'picture_2_order', 'picture_3_name', 
                'picture_3_url', 'picture_3_order', 'picture_4_name', 'picture_4_url', 
                'picture_4_order', 'picture_5_name', 'picture_5_url', 'picture_5_order'
            ],
            [
                'F-WL001', 'Shiny polyester 50D fabric', 'Fabrics', 'SUPP001', 
                'Polyester Fabrics', 'shiny,polyester,jacket,outerwear', 'polyester', 'silver', 
                'ladies,unisex', 'casual', 'MAR', 'MAR,MMC', '50D', 'fabric_front.jpg', 
                'http://example.com/fabric_front.jpg', '1', '', '', '', '', '', '', '', '', '', '', '', ''
            ]
        ]
        
        # Create CSV in memory
        output = io.StringIO()
        writer = csv.writer(output, delimiter=';')
        for row in template_data:
            writer.writerow(row)
        
        # Create file-like object
        csv_data = output.getvalue()
        output.close()
        
        # Return as downloadable file
        return current_app.response_class(
            csv_data,
            mimetype='text/csv',
            headers={
                'Content-Disposition': 'attachment; filename=component_template.csv'
            }
        )
        
    except Exception as e:
        current_app.logger.error(f"Error generating CSV template: {str(e)}")
        flash('Error generating template', 'danger')
        return redirect(url_for('main.upload_csv'))

# API Routes for AJAX functionality
@main.route('/api/components/search')
def api_search_components():
    """API endpoint for component search with autocomplete."""
    try:
        query = request.args.get('q', '').strip()
        limit = min(int(request.args.get('limit', 10)), 50)
        
        if len(query) < 2:
            return jsonify([])
        
        components = Component.query.filter(
            or_(
                Component.product_number.ilike(f'%{query}%'),
                Component.description.ilike(f'%{query}%')
            )
        ).limit(limit).all()
        
        results = [{
            'id': c.id,
            'product_number': c.product_number,
            'description': c.description,
            'supplier': c.supplier.supplier_code,
            'type': c.component_type.name
        } for c in components]
        
        return jsonify(results)
        
    except Exception as e:
        current_app.logger.error(f"Error in component search: {str(e)}")
        return jsonify({'error': 'Search failed'}), 500

@main.route('/api/components/<int:component_id>/duplicate', methods=['POST'])
def api_duplicate_component(component_id):
    """API endpoint to duplicate a component."""
    try:
        original = Component.query.get_or_404(component_id)
        
        # Create new component with modified product number
        new_product_number = f"{original.product_number}_COPY_{datetime.now().strftime('%Y%m%d%H%M%S')}"
        
        new_component = Component(
            product_number=new_product_number,
            description=f"Copy of {original.description}",
            component_type_id=original.component_type_id,
            supplier_id=original.supplier_id,
            category_id=original.category_id,
            properties=original.properties.copy() if original.properties else {}
        )
        
        db.session.add(new_component)
        db.session.flush()
        
        # Copy keywords
        for keyword in original.keywords:
            new_component.keywords.append(keyword)
        
        db.session.commit()
        
        return jsonify({
            'success': True,
            'new_id': new_component.id,
            'new_product_number': new_product_number
        })
        
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f"Error duplicating component: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 500

@main.route('/api/components/<int:component_id>/export')
def api_export_component(component_id):
    """API endpoint to export component data."""
    try:
        component = Component.query.options(
            db.joinedload(Component.component_type),
            db.joinedload(Component.supplier),
            db.joinedload(Component.category),
            db.joinedload(Component.keywords),
            db.joinedload(Component.pictures)
        ).get_or_404(component_id)
        
        export_data = {
            'product_number': component.product_number,
            'description': component.description,
            'component_type': component.component_type.name,
            'supplier_code': component.supplier.supplier_code,
            'category_name': component.category.name,
            'keywords': [k.name for k in component.keywords],
            'properties': component.properties,
            'pictures': [{
                'name': p.picture_name,
                'url': p.url,
                'order': p.picture_order
            } for p in component.pictures],
            'status': {
                'proto': {
                    'status': component.proto_status,
                    'comment': component.proto_comment,
                    'date': component.proto_date.isoformat() if component.proto_date else None
                },
                'sms': {
                    'status': component.sms_status,
                    'comment': component.sms_comment,
                    'date': component.sms_date.isoformat() if component.sms_date else None
                },
                'pps': {
                    'status': component.pps_status,
                    'comment': component.pps_comment,
                    'date': component.pps_date.isoformat() if component.pps_date else None
                }
            },
            'created_at': component.created_at.isoformat() if component.created_at else None,
            'updated_at': component.updated_at.isoformat() if component.updated_at else None
        }
        
        # Return as JSON download
        json_data = json.dumps(export_data, indent=2)
        return current_app.response_class(
            json_data,
            mimetype='application/json',
            headers={
                'Content-Disposition': f'attachment; filename=component_{component.product_number}.json'
            }
        )
        
    except Exception as e:
        current_app.logger.error(f"Error exporting component: {str(e)}")
        return jsonify({'error': 'Export failed'}), 500

@main.route('/api/components/bulk-delete', methods=['POST'])
def api_bulk_delete_components():
    """API endpoint for bulk deletion of components."""
    try:
        data = request.get_json()
        component_ids = data.get('ids', [])
        
        if not component_ids:
            return jsonify({'success': False, 'error': 'No components selected'}), 400
        
        # Delete components
        deleted_count = Component.query.filter(Component.id.in_(component_ids)).delete()
        db.session.commit()
        
        return jsonify({
            'success': True,
            'deleted_count': deleted_count
        })
        
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f"Error in bulk delete: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 500

# Helper functions
def _process_component_properties(component, component_type_name, form_data):
    """Process component properties based on component type."""
    type_properties = {
        'Fabrics': ['material', 'color', 'gender', 'brand', 'finish', 'weight'],
        'Shapes': ['gender', 'style', 'brand', 'subbrand', 'subcategory'],
        'Buttons': ['material', 'color', 'brand', 'size'],
        'Zippers': ['material', 'color', 'brand', 'size'],
        'Labels': ['brand', 'subbrand', 'material'],
        'Hangtags': ['brand', 'subbrand', 'material'],
        'Packaging': ['brand', 'material']
    }
    
    allowed_properties = type_properties.get(component_type_name, [])
    
    for prop in allowed_properties:
        prop_value = form_data.get(prop)
        if prop_value:
            # Handle array properties
            if prop in ['gender', 'style', 'subbrand']:
                if isinstance(prop_value, list):
                    component.set_property(prop, prop_value, 'array')
                else:
                    # Convert string to array if needed
                    values = [v.strip() for v in prop_value.split(',') if v.strip()]
                    if values:
                        component.set_property(prop, values, 'array')
            else:
                component.set_property(prop, prop_value, 'text')

def _process_image_uploads(component, request):
    """Process image uploads for a component."""
    uploaded_count = 0
    for i in range(1, 6):  # Up to 5 pictures
        picture_file = request.files.get(f'picture_{i}')
        picture_order = request.form.get(f'picture_{i}_order', i)
        
        if picture_file and picture_file.filename:
            try:
                # Generate unique filename
                filename = secure_filename(picture_file.filename)
                unique_filename = f"{uuid.uuid4().hex}_{filename}"
                
                # Save file
                picture_path = os.path.join(current_app.config['UPLOAD_FOLDER'], unique_filename)
                picture_file.save(picture_path)
                
                # Create picture record
                picture = Picture(
                    component_id=component.id,
                    picture_name=filename,
                    url=f"/static/uploads/{unique_filename}",
                    picture_order=int(picture_order)
                )
                db.session.add(picture)
                uploaded_count += 1
                
            except Exception as e:
                current_app.logger.error(f"Error uploading image {i}: {str(e)}")
                # Continue with other images
                continue
    
    return uploaded_count

def _update_component_images(component, request):
    """Update component images, handling both new uploads and existing images."""
    # Remove existing pictures
    Picture.query.filter_by(component_id=component.id).delete()
    
    # Process new uploaded images
    _process_image_uploads(component, request)
    
    # Process existing images that should be kept
    for i in range(1, 6):
        existing_url = request.form.get(f'existing_picture_{i}_url')
        existing_name = request.form.get(f'existing_picture_{i}_name')
        existing_order = request.form.get(f'existing_picture_{i}_order')
        
        if existing_url and existing_name and existing_order:
            picture = Picture(
                component_id=component.id,
                picture_name=existing_name,
                url=existing_url,
                picture_order=int(existing_order)
            )
            db.session.add(picture)

# Additional utility routes and existing routes (suppliers, etc.) would go here...
# For brevity, I'm including the essential enhanced routes that support the modern frontend
# Add these routes to your app/routes.py file (after the existing routes)

# Replace the suppliers route in app/routes.py with this fixed version:

# Replace the suppliers route in app/routes.py with this fixed version:

@main.route('/suppliers')
def suppliers():
    """Display all suppliers with management interface."""
    try:
        suppliers_query = Supplier.query.order_by(Supplier.supplier_code).all()
        
        # Convert suppliers to JSON-serializable format
        suppliers_data = []
        for supplier in suppliers_query:
            supplier_dict = {
                'id': supplier.id,
                'supplier_code': supplier.supplier_code,
                'address': supplier.address,
                'created_at': supplier.created_at.isoformat() if supplier.created_at else None,
                'updated_at': supplier.updated_at.isoformat() if supplier.updated_at else None,
                'components': [
                    {
                        'id': comp.id,
                        'product_number': comp.product_number,
                        'description': comp.description,
                        'created_at': comp.created_at.isoformat() if comp.created_at else None
                    } for comp in supplier.components
                ]
            }
            suppliers_data.append(supplier_dict)
        
        return render_template('suppliers.html', 
                             suppliers=suppliers_query,  # For server-side rendering
                             suppliers_data=suppliers_data)  # For JavaScript
        
    except Exception as e:
        current_app.logger.error(f"Error loading suppliers: {str(e)}")
        flash(f'Error loading suppliers: {str(e)}', 'danger')
        return redirect(url_for('main.index'))1~# Replace the suppliers route in app/routes.py with this fixed version:

@main.route('/suppliers')
def suppliers():
    """Display all suppliers with management interface."""
    try:
        suppliers_query = Supplier.query.order_by(Supplier.supplier_code).all()
        
        # Convert suppliers to JSON-serializable format
        suppliers_data = []
        for supplier in suppliers_query:
            supplier_dict = {
                'id': supplier.id,
                'supplier_code': supplier.supplier_code,
                'address': supplier.address,
                'created_at': supplier.created_at.isoformat() if supplier.created_at else None,
                'updated_at': supplier.updated_at.isoformat() if supplier.updated_at else None,
                'components': [
                    {
                        'id': comp.id,
                        'product_number': comp.product_number,
                        'description': comp.description,
                        'created_at': comp.created_at.isoformat() if comp.created_at else None
                    } for comp in supplier.components
                ]
            }
            suppliers_data.append(supplier_dict)
        
        return render_template('suppliers.html', 
                             suppliers=suppliers_query,  # For server-side rendering
                             suppliers_data=suppliers_data)  # For JavaScript
        
    except Exception as e:
        current_app.logger.error(f"Error loading suppliers: {str(e)}")
        flash(f'Error loading suppliers: {str(e)}', 'danger')
        return redirect(url_for('main.index'))1~

# Replace the suppliers route in app/routes.py with this fixed version:

@main.route('/suppliers')
def suppliers():
    """Display all suppliers with management interface."""
    try:
        suppliers_query = Supplier.query.order_by(Supplier.supplier_code).all()
        
        # Convert suppliers to JSON-serializable format
        suppliers_data = []
        for supplier in suppliers_query:
            supplier_dict = {
                'id': supplier.id,
                'supplier_code': supplier.supplier_code,
                'address': supplier.address,
                'created_at': supplier.created_at.isoformat() if supplier.created_at else None,
                'updated_at': supplier.updated_at.isoformat() if supplier.updated_at else None,
                'components': [
                    {
                        'id': comp.id,
                        'product_number': comp.product_number,
                        'description': comp.description,
                        'created_at': comp.created_at.isoformat() if comp.created_at else None
                    } for comp in supplier.components
                ]
            }
            suppliers_data.append(supplier_dict)
        
        return render_template('suppliers.html', 
                             suppliers=suppliers_query,  # For server-side rendering
                             suppliers_data=suppliers_data)  # For JavaScript
        
    except Exception as e:
        current_app.logger.error(f"Error loading suppliers: {str(e)}")
        flash(f'Error loading suppliers: {str(e)}', 'danger')
        return redirect(url_for('main.index'))

@main.route('/supplier/new', methods=['GET', 'POST'])
def new_supplier():
    """Create a new supplier."""
    if request.method == 'POST':
        try:
            supplier_code = request.form.get('supplier_code', '').strip()
            address = request.form.get('address', '').strip()
            
            if not supplier_code:
                flash('Supplier code is required.', 'danger')
                return redirect(request.url)
            
            # Check if supplier code already exists
            existing = Supplier.query.filter_by(supplier_code=supplier_code).first()
            if existing:
                flash('Supplier code already exists.', 'danger')
                return redirect(request.url)
            
            # Create new supplier
            supplier = Supplier(
                supplier_code=supplier_code,
                address=address if address else None
            )
            
            db.session.add(supplier)
            db.session.commit()
            
            flash('Supplier created successfully!', 'success')
            return redirect(url_for('main.suppliers'))
            
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Error creating supplier: {str(e)}")
            flash(f'Error creating supplier: {str(e)}', 'danger')
            return redirect(request.url)
    
    # GET request - show form
    return render_template('supplier_form.html')

@main.route('/supplier/edit/<int:id>', methods=['GET', 'POST'])
def edit_supplier(id):
    """Edit an existing supplier."""
    supplier = Supplier.query.get_or_404(id)
    
    if request.method == 'POST':
        try:
            supplier_code = request.form.get('supplier_code', '').strip()
            address = request.form.get('address', '').strip()
            
            if not supplier_code:
                flash('Supplier code is required.', 'danger')
                return redirect(request.url)
            
            # Check if supplier code already exists (excluding current supplier)
            existing = Supplier.query.filter(
                Supplier.supplier_code == supplier_code,
                Supplier.id != id
            ).first()
            if existing:
                flash('Supplier code already exists.', 'danger')
                return redirect(request.url)
            
            # Update supplier
            supplier.supplier_code = supplier_code
            supplier.address = address if address else None
            
            db.session.commit()
            
            flash('Supplier updated successfully!', 'success')
            return redirect(url_for('main.suppliers'))
            
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Error updating supplier: {str(e)}")
            flash(f'Error updating supplier: {str(e)}', 'danger')
            return redirect(request.url)
    
    # GET request - show form with existing data
    return render_template('supplier_form.html', supplier=supplier)

@main.route('/supplier/delete/<int:id>', methods=['POST'])
def delete_supplier(id):
    """Delete a supplier."""
    try:
        supplier = Supplier.query.get_or_404(id)
        
        # Check if supplier has any components
        if supplier.components:
            flash(f'Cannot delete supplier {supplier.supplier_code}. It has {len(supplier.components)} associated components.', 'danger')
            return redirect(url_for('main.suppliers'))
        
        db.session.delete(supplier)
        db.session.commit()
        
        flash('Supplier deleted successfully!', 'success')
        return redirect(url_for('main.suppliers'))
        
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f"Error deleting supplier {id}: {str(e)}")
        flash(f'Error deleting supplier: {str(e)}', 'danger')
        return redirect(url_for('main.suppliers'))

# API routes for supplier management (for AJAX functionality)
@main.route('/api/suppliers/<int:supplier_id>', methods=['PUT'])
def api_update_supplier(supplier_id):
    """API endpoint to update a supplier."""
    try:
        supplier = Supplier.query.get_or_404(supplier_id)
        
        data = request.get_json() or request.form
        supplier_code = data.get('supplier_code', '').strip()
        address = data.get('address', '').strip()
        
        if not supplier_code:
            return jsonify({'success': False, 'error': 'Supplier code is required'}), 400
        
        # Check for duplicate supplier code
        existing = Supplier.query.filter(
            Supplier.supplier_code == supplier_code,
            Supplier.id != supplier_id
        ).first()
        if existing:
            return jsonify({'success': False, 'error': 'Supplier code already exists'}), 400
        
        supplier.supplier_code = supplier_code
        supplier.address = address if address else None
        
        db.session.commit()
        
        return jsonify({'success': True})
        
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f"Error updating supplier via API: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 500

@main.route('/api/suppliers/<int:supplier_id>', methods=['DELETE'])
def api_delete_supplier(supplier_id):
    """API endpoint to delete a supplier."""
    try:
        supplier = Supplier.query.get_or_404(supplier_id)
        
        # Check if supplier has any components
        if supplier.components:
            return jsonify({
                'success': False, 
                'error': f'Cannot delete supplier. It has {len(supplier.components)} associated components.'
            }), 400
        
        db.session.delete(supplier)
        db.session.commit()
        
        return jsonify({'success': True})
        
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f"Error deleting supplier via API: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 500

@main.route('/api/suppliers/bulk-delete', methods=['POST'])
def api_bulk_delete_suppliers():
    """API endpoint for bulk deletion of suppliers."""
    try:
        data = request.get_json()
        supplier_ids = data.get('ids', [])
        
        if not supplier_ids:
            return jsonify({'success': False, 'error': 'No suppliers selected'}), 400
        
        # Check if any suppliers have components
        suppliers_with_components = Supplier.query.filter(
            Supplier.id.in_(supplier_ids)
        ).filter(Supplier.components.any()).all()
        
        if suppliers_with_components:
            supplier_codes = [s.supplier_code for s in suppliers_with_components]
            return jsonify({
                'success': False, 
                'error': f'Cannot delete suppliers with components: {", ".join(supplier_codes)}'
            }), 400
        
        # Delete suppliers
        deleted_count = Supplier.query.filter(Supplier.id.in_(supplier_ids)).delete()
        db.session.commit()
        
        return jsonify({
            'success': True,
            'deleted_count': deleted_count
        })
        
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f"Error in bulk delete suppliers: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 500

@main.route('/api/suppliers/export')
def api_export_suppliers():
    """API endpoint to export suppliers data."""
    try:
        suppliers = Supplier.query.order_by(Supplier.supplier_code).all()
        
        # Create CSV data
        import io
        import csv
        
        output = io.StringIO()
        writer = csv.writer(output)
        
        # Write header
        writer.writerow(['Supplier Code', 'Address', 'Components Count', 'Created At'])
        
        # Write data
        for supplier in suppliers:
            writer.writerow([
                supplier.supplier_code,
                supplier.address or '',
                len(supplier.components),
                supplier.created_at.strftime('%Y-%m-%d') if supplier.created_at else ''
            ])
        
        csv_data = output.getvalue()
        output.close()
        
        # Return as downloadable file
        return current_app.response_class(
            csv_data,
            mimetype='text/csv',
            headers={
                'Content-Disposition': 'attachment; filename=suppliers.csv'
            }
        )
        
    except Exception as e:
        current_app.logger.error(f"Error exporting suppliers: {str(e)}")
        return jsonify({'error': 'Export failed'}), 500
