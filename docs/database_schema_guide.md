# Database Schema Guide - Component Management System

**Database**: `promo_database`  
**Schema**: `component_app`  
**Connection**: `postgresql://component_user:component_app_123@192.168.100.35:5432/promo_database`

## Core Architecture Overview

```
Component Management System Database Schema (component_app)

Core Entities:
├── component (main product entity)
│   ├── component_variant (color variants with auto-generated SKUs)
│   │   └── picture (variant-specific images)
│   ├── picture (component-level images) 
│   ├── component_brand (many-to-many brand associations)
│   └── keyword_component (many-to-many keyword associations)
├── component_type (product categories)
│   └── component_type_property (dynamic properties per type)
├── supplier (supplier management)
├── brand (brand management)
│   └── subbrand (brand hierarchy)
└── Reference Tables (color, material, category, etc.)
```

## Table Structure & Relationships

### Core Tables

#### `property` - Master Property Definitions
```sql
PRIMARY KEY: id (serial)
UNIQUE CONSTRAINT: property_key

Columns:
- id: Primary key
- property_key: Unique identifier (e.g., 'material', 'color', 'style')
- display_name: Human-readable name for UI
- data_type: UI widget type ('select', 'text', 'pdf', 'picture', 'multiselect')
- description: Property description
- is_active: Enable/disable property
- options: JSON array of options (populated from reference tables)
- created_at, updated_at: Automatic timestamps

Dynamic Options Population:
- property_key 'material' → options from material table
- property_key 'color' → options from color table  
- property_key 'category' → options from category table
- Custom properties → static options in JSON field

Business Rules:
- Options dynamically populated based on property_key naming convention
- data_type determines UI rendering (select dropdown, text input, file upload)
- property_key maps to reference tables for structured data
```

#### `component_type_property` - Component Type Property Configuration
```sql
PRIMARY KEY: id (serial)
UNIQUE CONSTRAINT: (component_type_id, property_name)

Columns:
- id: Primary key
- component_type_id: FK to component_type (REQUIRED)
- property_name: Maps to property.property_key
- property_type: Data type for validation
- is_required: Validation flag
- display_order: UI ordering

Purpose: Defines which properties are available/required for each component type

Business Logic:
- Links component types to available properties from property table
- Enables different component types to have different property sets
- Supports validation rules (required/optional) per component type
- Controls UI form generation order via display_order

Example Configuration:
- T-Shirt component type → material (required), color (required), style (optional)
- Electronics component type → material (required), warranty (required)
```

#### `component` - Main Product Entity
```sql
PRIMARY KEY: id (serial)
UNIQUE CONSTRAINT: (product_number, supplier_id)

Columns:
- id: Primary key
- product_number: Product identifier (not globally unique - unique per supplier)
- description: Product description  
- component_type_id: FK to component_type (REQUIRED)
- supplier_id: FK to supplier (OPTIONAL)
- properties: JSONB for dual property system (predefined + custom properties)
- proto_status, sms_status, pps_status: Workflow statuses ('pending'|'ok'|'not_ok')
- proto_comment, sms_comment, pps_comment: Status comments
- proto_date, sms_date, pps_date: Status timestamps
- created_at, updated_at: Automatic timestamps

Relationships:
- component_type (many-to-one)
- supplier (many-to-one, optional)
- variants (one-to-many → component_variant)
- pictures (one-to-many → picture)
- brand_associations (one-to-many → component_brand)
- keywords (many-to-many via keyword_component)
```

#### `component_variant` - Color Variants
```sql
PRIMARY KEY: id (serial)
UNIQUE CONSTRAINT: (component_id, color_id)

Columns:
- id: Primary key
- component_id: FK to component (REQUIRED)
- color_id: FK to color (REQUIRED)
- variant_name: Display name (optional)
- variant_sku: Auto-generated by database trigger
- is_active: Boolean flag
- created_at, updated_at: Automatic timestamps

Auto-Generated SKU Patterns:
- With supplier: "supplier_code_product_number_color_name"
- Without supplier: "product_number_color_name"

Relationships:
- component (many-to-one)
- color (many-to-one)
- variant_pictures (one-to-many → picture where variant_id IS NOT NULL)
```

#### `picture` - Image Management
```sql
PRIMARY KEY: id (serial)
UNIQUE CONSTRAINT: (variant_id, picture_order)

Columns:
- id: Primary key
- component_id: FK to component (REQUIRED - always set)
- variant_id: FK to component_variant (OPTIONAL - NULL for component pictures)
- picture_name: Auto-generated by database trigger
- url: WebDAV URL to actual file
- picture_order: Order within variant/component
- alt_text: Accessibility text
- file_size: File size in bytes
- is_primary: Primary image flag
- created_at: Creation timestamp

Auto-Generated Name Patterns:
**Component Pictures (variant_id = NULL):**
- With supplier: `{supplier_code}_{product_number}_{order}.jpg`
- Without supplier: `{product_number}_{order}.jpg`

**Variant Pictures (variant_id = NOT NULL):**
- With supplier: `{supplier_code}_{product_number}_{color_name}_{order}.jpg`  
- Without supplier: `{product_number}_{color_name}_{order}.jpg`

**Examples:**
```
Component Pictures:
├── sup001_widget-123_1.jpg     # With supplier
├── sup001_widget-123_2.jpg     # With supplier, order 2
└── widget-789_1.jpg            # Without supplier

Variant Pictures:
├── sup001_widget-123_red_1.jpg   # With supplier, red variant
├── sup001_widget-123_blue_2.jpg  # With supplier, blue variant, order 2
├── widget-789_green_1.jpg        # Without supplier, green variant
└── widget-789_black_3.jpg        # Without supplier, black variant, order 3
```

**Critical Business Rule - Picture Renaming:**
When component.product_number changes, ALL related pictures must be renamed:
- Database triggers update picture_name automatically
- WebDAV files must be moved/renamed to match new picture_name
- Operation must be atomic (database + WebDAV both succeed or both rollback)

Picture Types:
- Component Pictures: variant_id IS NULL (general product images)
- Variant Pictures: variant_id IS NOT NULL (color-specific images)

Relationships:
- parent_component (many-to-one via component_id)
- variant (many-to-one via variant_id, optional)
```

### Association Tables

#### `component_brand` - Component-Brand Associations
```sql
PRIMARY KEY: id (serial)
UNIQUE CONSTRAINT: (component_id, brand_id)

Purpose: Many-to-many relationship between components and brands
```

#### `keyword_component` - Component-Keyword Associations  
```sql
PRIMARY KEY: id (serial)
UNIQUE CONSTRAINT: (component_id, keyword_id)

Purpose: Many-to-many relationship for tagging components
```

### Reference Data Tables

#### `component_type` - Product Categories
```sql
Columns:
- id, name
- Defines what properties are available via component_type_property

Relationships:
- components (one-to-many)
- type_properties (one-to-many → component_type_property)
```

#### `component_type_property` - Dynamic Properties
```sql
Purpose: Defines available properties for each component type
Columns:
- component_type_id, property_name, property_type
- is_required, display_order

Example: Component type "T-Shirt" might have properties:
- material (select)
- size (multiselect)  
- care_instructions (text)
```

#### `supplier` - Supplier Management
```sql
Columns:
- id, supplier_code (unique), address
- created_at, updated_at

Key Feature: supplier_code used in auto-generated SKUs
```

#### `brand` / `subbrand` - Brand Hierarchy
```sql
brand: id, name, created_at, updated_at
subbrand: id, name, brand_id, created_at, updated_at

Hierarchy: Brand → Subbrand → Component (via component_brand)
```

#### Basic Reference Tables
```sql
color: id, name (unique)
material: id, name (unique)  
category: id, name (unique)
keyword: id, name (unique)
gender: id, name
style: id, name
property: id, property_key, display_name, data_type, options (JSON)
```

## Database Triggers & Functions

### Auto-Generation Functions

#### `generate_variant_sku(component_id, color_id)`
```sql
Purpose: Auto-generates variant SKUs
Pattern: 
- With supplier: "supplier_code_product_number_color_name"
- Without supplier: "product_number_color_name"

Triggered: ON INSERT/UPDATE of component_variant
```

#### `generate_picture_name(component_id, variant_id, picture_order)`
```sql
Purpose: Auto-generates picture names with supplier code handling
Pattern Logic:
1. Get component details (product_number, supplier_id)
2. Get supplier_code from supplier table (if supplier_id exists)
3. Get color_name from color table (if variant_id exists)
4. Generate name based on pattern:

Component Pictures (variant_id = NULL):
- supplier_code EXISTS: "{supplier_code}_{product_number}_{order}"
- supplier_code IS NULL: "{product_number}_{order}"

Variant Pictures (variant_id NOT NULL):  
- supplier_code EXISTS: "{supplier_code}_{product_number}_{color_name}_{order}"
- supplier_code IS NULL: "{product_number}_{color_name}_{order}"

Supplier Code Handling:
- If component.supplier_id IS NULL → no supplier prefix
- If component.supplier_id EXISTS but supplier.supplier_code IS NULL/empty → no supplier prefix
- Only include supplier_code when it's a valid non-empty string

Triggered: ON INSERT/UPDATE of picture
```

#### `update_updated_at_column()`
```sql
Purpose: Automatic timestamp management
Triggered: ON UPDATE for all tables with updated_at column
```

### Cascade Triggers

#### `update_variant_skus_on_component_change()`
- Updates all variant SKUs when component product_number or supplier changes

#### `update_variant_skus_on_supplier_change()`  
- Updates all variant SKUs when supplier_code changes

#### `update_variant_skus_on_color_change()`
- Updates all variant SKUs when color name changes

#### `update_picture_names_on_*_change()`
- Similar cascade updates for picture names

#### `ensure_picture_component_id()`
- Automatically sets component_id when variant_id is provided

## Dynamic Property System Architecture

### Dual Property System Design

The component management system implements a sophisticated dual property system:

#### **1. Predefined Properties (Structured)**
```
property → component_type_property → component_type → component.properties (structured data)
```

**Flow**:
1. **Property Definition**: Admin defines property in `property` table
2. **Type Assignment**: Property linked to component types via `component_type_property`
3. **Form Generation**: UI automatically generates form fields based on component type
4. **Data Storage**: Values stored in component.properties JSONB with validation

**Example**:
```sql
-- Property definition
property: {property_key: "material", data_type: "select", options: ["Cotton", "Polyester"]}

-- Type assignment  
component_type_property: {component_type_id: 1, property_name: "material", is_required: true}

-- Data storage
component.properties: {"material": "Cotton", "custom_notes": "Special fabric"}
```

#### **2. Custom Properties (Flexible)**
```
User Input → component.properties (flexible JSONB)
```

Users can add any custom properties not defined in the predefined system:
```json
{
  "material": "Cotton",           // Predefined property
  "custom_thread_count": 200,     // Custom property
  "special_treatment": "waterproof", // Custom property  
  "internal_notes": "Handle with care" // Custom property
}
```

#### **3. Dynamic Options Population**

Options for predefined properties are populated dynamically:

```python
# System automatically populates options based on property_key
if property.property_key == "material":
    property.options = Material.query.all()  # From material table
elif property.property_key == "color":
    property.options = Color.query.all()     # From color table
elif property.property_key == "category":
    property.options = Category.query.all()  # From category table
```

#### **4. Form Generation Logic**

The system generates forms automatically:

1. **Get Component Type**: Identify component type from form/context
2. **Load Properties**: Query component_type_property for available properties  
3. **Resolve Options**: Populate options from reference tables
4. **Render Form**: Generate appropriate UI widgets based on data_type
5. **Validate Input**: Apply required/optional rules per component type

#### **5. Data Validation**

**Predefined Properties**: 
- Validated against property.options
- Required/optional per component_type_property.is_required
- Type validation per property.data_type

**Custom Properties**:
- No structural validation (user freedom)
- Stored as-is in JSONB field
- Can be any JSON-compatible data type

## Data Flow & Business Rules

### Component Creation Workflow
1. **Component created** with basic info (product_number, type, supplier)
2. **Variants added** with color selections
3. **Database triggers generate** variant SKUs automatically
4. **Pictures uploaded** for each variant
5. **Database triggers generate** picture names automatically
6. **URLs set** pointing to WebDAV storage

### Picture Management Rules
- **Pictures stored in WebDAV**: `http://31.182.67.115/webdav/components/`
- **No subdirectories**: All files in `/components/` root
- **Auto-naming**: Never manually set picture_name or variant_sku
- **Component requirement**: Every picture must have component_id
- **Variant linking**: variant_id optional (NULL for component pictures)

### Unique Constraints & Validation
- **product_number + supplier_id**: Must be unique combination
- **component_id + color_id**: Each component can have only one variant per color
- **variant_id + picture_order**: Pictures ordered within each variant
- **picture_name**: Globally unique across all pictures

### Status Management
- **Three-tier approval**: Proto → SMS → PPS
- **Component-level**: Status applies to entire product and all variants
- **Default state**: All statuses start as 'pending'
- **Valid states**: 'pending', 'ok', 'not_ok'

## Critical Database Operations

### Safe Operations (Recommended)
```sql
-- Let triggers handle auto-generation
INSERT INTO component_variant (component_id, color_id) VALUES (1, 1);
INSERT INTO picture (component_id, variant_id, picture_order) VALUES (1, 1, 1);

-- Update will trigger regeneration
UPDATE component SET product_number = 'NEW_PRODUCT' WHERE id = 1;
```

### Dangerous Operations (Avoid)
```sql
-- DON'T manually set auto-generated fields
INSERT INTO component_variant (component_id, color_id, variant_sku) VALUES (1, 1, 'MANUAL_SKU');
INSERT INTO picture (component_id, picture_name) VALUES (1, 'manual_name');

-- DON'T bypass component_id requirement
INSERT INTO picture (variant_id, picture_order) VALUES (1, 1); -- Missing component_id
```

## Performance Considerations

### Efficient Queries
```python
# Use selectinload for relationships
component = Component.query.options(
    selectinload(Component.variants).joinedload(ComponentVariant.color),
    selectinload(Component.pictures)
).get(id)

# Clear session after picture operations
db.session.expunge_all()
```

### Index Strategy
- **Primary keys**: Automatic indexes
- **Foreign keys**: Indexes on component_id, variant_id, etc.
- **Unique constraints**: Automatic unique indexes
- **JSON properties**: GIN index on component.properties

## WebDAV Integration

### File Storage Pattern
```
WebDAV Root: http://31.182.67.115/webdav/components/
Local Mount: /components/

File Pattern: {picture_name}.{extension}
Example: supplier_product_red_1.jpg
```

### URL Construction
```
Database: picture.picture_name = "supplier_product_red_1"
File Extension: .jpg (from uploaded file)
Final Filename: supplier_product_red_1.jpg
WebDAV URL: http://31.182.67.115/webdav/components/supplier_product_red_1.jpg
```

## Troubleshooting Common Issues

### SKU Generation Problems
- **Check supplier_code**: Must be set in supplier table
- **Verify triggers**: Ensure database triggers are active
- **Check color names**: Color names affect SKU generation

### Picture Upload Issues  
- **Verify WebDAV mount**: Check `/components/` accessibility
- **Check file permissions**: Ensure write access to mount point
- **Validate extensions**: Only .jpg, .jpeg, .png, .gif, .webp allowed
- **File size limits**: 16MB maximum

### Database Constraints
- **Duplicate SKUs**: Usually indicates trigger failure
- **Missing component_id**: Picture trigger should auto-populate
- **Unique violations**: Check for existing variants/pictures

This schema supports flexible component management with automatic naming, multi-status workflows, and efficient relationship management through PostgreSQL triggers and constraints.